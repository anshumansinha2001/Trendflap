Perfect 👌 you’re thinking production-grade now — proper validation + sending real error messages back to the frontend is 🔑 for a good DX/UX.

Here’s how we’ll do it:

✅ Improvements we’ll add

Mongoose validation → already in schema (e.g. required, enum, unique).

Better error handling in API route → catch Mongoose errors and send meaningful messages to frontend (instead of generic 500).

Consistent error format → { success: false, message: "..." }.

📝 Updated BlogModel.js (unchanged, but keeps validation)
import mongoose from "mongoose";

const { Schema } = mongoose;

const blogSchema = new Schema(
  {
    title: {
      type: String,
      required: [true, "Blog title is required"],
      trim: true,
    },
    slug: {
      type: String,
      required: [true, "Slug is required"],
      unique: true,
      lowercase: true,
      trim: true,
    },
    metaTitle: { type: String, trim: true },
    metaDescription: { type: String, trim: true },
    category: {
      type: String,
      enum: ["AI", "Tech", "Digital Marketing"],
      required: [true, "Category is required"],
    },
    read: { type: String, trim: true },
    date: {
      type: String,
      default: () => new Date().toDateString(),
    },
    image: { type: String },
    imageAlt: { type: String },
    isFeatured: { type: Boolean, default: false },
    tldr: [{ type: String }],
    toc: [{ id: String, text: String }],
    content: {
      type: String,
      required: [true, "Content is required"],
    },
    faq: [
      {
        question: { type: String, required: true },
        answer: { type: String, required: true },
      },
    ],
  },
  { timestamps: true }
);

const Blog = mongoose.models.Blog || mongoose.model("Blog", blogSchema);

export default Blog;

📝 API Route with Better Error Handling

app/api/blogs/route.js

import connectDB from "@/lib/config/db";
import Blog from "@/models/BlogModel";

// GET all blogs
export async function GET() {
  try {
    await connectDB();
    const blogs = await Blog.find().sort({ createdAt: -1 });
    return Response.json({ success: true, data: blogs });
  } catch (error) {
    return Response.json(
      { success: false, message: "Failed to fetch blogs", error: error.message },
      { status: 500 }
    );
  }
}

// POST create blog
export async function POST(req) {
  await connectDB();
  const data = await req.json();

  try {
    const blog = await Blog.create(data);
    return Response.json({ success: true, data: blog }, { status: 201 });
  } catch (error) {
    // Handle validation errors
    if (error.name === "ValidationError") {
      const messages = Object.values(error.errors).map((err) => err.message);
      return Response.json(
        { success: false, message: "Validation error", errors: messages },
        { status: 400 }
      );
    }

    // Handle duplicate slug error
    if (error.code === 11000) {
      return Response.json(
        { success: false, message: "Slug already exists. Choose another one." },
        { status: 400 }
      );
    }

    // Fallback
    return Response.json(
      { success: false, message: "Server error", error: error.message },
      { status: 500 }
    );
  }
}

🧑‍💻 Example frontend usage with Axios + Toast
import axios from "axios";
import { toast } from "react-toastify";

async function createBlog(blogData) {
  try {
    const res = await axios.post("/api/blogs", blogData);

    if (res.data.success) {
      toast.success("Blog created successfully!");
    }
  } catch (err) {
    if (err.response?.data?.errors) {
      // Validation errors
      err.response.data.errors.forEach((msg) => toast.error(msg));
    } else {
      toast.error(err.response?.data?.message || "Something went wrong");
    }
  }
}

✅ How this helps

If a required field is missing → frontend sees "Blog title is required" or "Content is required".

If slug is duplicate → frontend sees "Slug already exists. Choose another one.".

If anything else fails → frontend sees "Server error" with details.
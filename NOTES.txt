Perfect ðŸ‘Œ youâ€™re thinking production-grade now â€” proper validation + sending real error messages back to the frontend is ðŸ”‘ for a good DX/UX.

Hereâ€™s how weâ€™ll do it:

âœ… Improvements weâ€™ll add

Mongoose validation â†’ already in schema (e.g. required, enum, unique).

Better error handling in API route â†’ catch Mongoose errors and send meaningful messages to frontend (instead of generic 500).

Consistent error format â†’ { success: false, message: "..." }.

ðŸ“ Updated BlogModel.js (unchanged, but keeps validation)
import mongoose from "mongoose";

const { Schema } = mongoose;

const blogSchema = new Schema(
  {
    title: {
      type: String,
      required: [true, "Blog title is required"],
      trim: true,
    },
    slug: {
      type: String,
      required: [true, "Slug is required"],
      unique: true,
      lowercase: true,
      trim: true,
    },
    metaTitle: { type: String, trim: true },
    metaDescription: { type: String, trim: true },
    category: {
      type: String,
      enum: ["AI", "Tech", "Digital Marketing"],
      required: [true, "Category is required"],
    },
    read: { type: String, trim: true },
    date: {
      type: String,
      default: () => new Date().toDateString(),
    },
    image: { type: String },
    imageAlt: { type: String },
    isFeatured: { type: Boolean, default: false },
    tldr: [{ type: String }],
    toc: [{ id: String, text: String }],
    content: {
      type: String,
      required: [true, "Content is required"],
    },
    faq: [
      {
        question: { type: String, required: true },
        answer: { type: String, required: true },
      },
    ],
  },
  { timestamps: true }
);

const Blog = mongoose.models.Blog || mongoose.model("Blog", blogSchema);

export default Blog;

ðŸ“ API Route with Better Error Handling

app/api/blogs/route.js

import connectDB from "@/lib/config/db";
import Blog from "@/models/BlogModel";

// GET all blogs
export async function GET() {
  try {
    await connectDB();
    const blogs = await Blog.find().sort({ createdAt: -1 });
    return Response.json({ success: true, data: blogs });
  } catch (error) {
    return Response.json(
      { success: false, message: "Failed to fetch blogs", error: error.message },
      { status: 500 }
    );
  }
}

// POST create blog
export async function POST(req) {
  await connectDB();
  const data = await req.json();

  try {
    const blog = await Blog.create(data);
    return Response.json({ success: true, data: blog }, { status: 201 });
  } catch (error) {
    // Handle validation errors
    if (error.name === "ValidationError") {
      const messages = Object.values(error.errors).map((err) => err.message);
      return Response.json(
        { success: false, message: "Validation error", errors: messages },
        { status: 400 }
      );
    }

    // Handle duplicate slug error
    if (error.code === 11000) {
      return Response.json(
        { success: false, message: "Slug already exists. Choose another one." },
        { status: 400 }
      );
    }

    // Fallback
    return Response.json(
      { success: false, message: "Server error", error: error.message },
      { status: 500 }
    );
  }
}

ðŸ§‘â€ðŸ’» Example frontend usage with Axios + Toast
import axios from "axios";
import { toast } from "react-toastify";

async function createBlog(blogData) {
  try {
    const res = await axios.post("/api/blogs", blogData);

    if (res.data.success) {
      toast.success("Blog created successfully!");
    }
  } catch (err) {
    if (err.response?.data?.errors) {
      // Validation errors
      err.response.data.errors.forEach((msg) => toast.error(msg));
    } else {
      toast.error(err.response?.data?.message || "Something went wrong");
    }
  }
}

âœ… How this helps

If a required field is missing â†’ frontend sees "Blog title is required" or "Content is required".

If slug is duplicate â†’ frontend sees "Slug already exists. Choose another one.".

If anything else fails â†’ frontend sees "Server error" with details.